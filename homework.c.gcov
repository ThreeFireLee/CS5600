        -:    0:Source:homework.c
        -:    0:Graph:homework.gcno
        -:    0:Data:homework.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2: * file:        homework.c
        -:    3: * description: skeleton file for CS 5600 homework 3
        -:    4: *
        -:    5: * CS 5600, Computer Systems, Northeastern CCIS
        -:    6: * Peter Desnoyers, November 2015
        -:    7: */
        -:    8:
        -:    9:#define FUSE_USE_VERSION 27
        -:   10:#define _GNU_SOURCE
        -:   11:
        -:   12:#include <stdlib.h>
        -:   13:#include <stddef.h>
        -:   14:#include <unistd.h>
        -:   15:#include <fuse.h>
        -:   16:#include <fcntl.h>
        -:   17:#include <string.h>
        -:   18:#include <stdio.h>
        -:   19:#include <errno.h>
        -:   20:#include <assert.h>
        -:   21:#include <time.h>
        -:   22:
        -:   23:#include "fs5600.h"
        -:   24:#include "blkdev.h"
        -:   25:
        -:   26:/*
        -:   27: * disk access - the global variable 'disk' points to a blkdev
        -:   28: *
        -:   29: * structure which has been initialized to access the image file.
        -:   30: * NOTE - blkdev access is in terms of 1024-byte blocks
        -:   31: */
        -:   32:
        -:   33:extern struct blkdev *disk;
        -:   34:
        -:   35:/* by defining bitmaps as 'fd_set' pointers, you can use existing
        -:   36: * macros to handle them.
        -:   37: *   FD_ISSET(##, inode_map);
        -:   38: *   FD_CLR(##, block_map);
        -:   39: *   FD_SET(##, block_map);
        -:   40: */
        -:   41:fd_set *inode_map;              /* = malloc(sb.inode_map_size * FS_BLOCK_SIZE); */
        -:   42:fd_set *block_map;
        -:   43:int inode_map_sz;
        -:   44:int block_map_sz;
        -:   45:int num_of_blocks;
        -:   46:struct fs5600_inode *inode_region;	/* inodes in memory */
        -:   47:void update_bitmap(void);
        -:   48:
        -:   49:// some constants
        -:   50:int file_in_inode_sz = N_DIRECT * BLOCK_SIZE;
        -:   51:int file_1st_level_sz = BLOCK_SIZE / sizeof(int) * BLOCK_SIZE;
        -:   52:int file_2nd_level_sz = (BLOCK_SIZE / sizeof(int)) * (BLOCK_SIZE / sizeof(int)) * BLOCK_SIZE;
        -:   53:
        -:   54:
        -:   55:/* init - this is called once by the FUSE framework at startup. Ignore
        -:   56: * the 'conn' argument.
        -:   57: * recommended actions:
        -:   58: *   - read superblock
        -:   59: *   - allocate memory, read bitmaps and inodes
        -:   60: */
      507:   61:void* fs_init(struct fuse_conn_info *conn)
        -:   62:{
        -:   63:    struct fs5600_super sb;
        -:   64:    /* here 1 stands for block size, here is 1024 bytes */
      507:   65:    disk->ops->read(disk, 0, 1, &sb);
        -:   66:
        -:   67:    /* your code here */
        -:   68:    /* read bitmaps */
      507:   69:    inode_map = malloc(sb.inode_map_sz * FS_BLOCK_SIZE);
      507:   70:    disk->ops->read(disk, 1, sb.inode_map_sz, inode_map);
      507:   71:    inode_map_sz = sb.inode_map_sz;
        -:   72:    // printf("%d\n", inode_map_sz);
        -:   73:
      507:   74:    block_map = malloc(sb.block_map_sz * FS_BLOCK_SIZE);
      507:   75:    disk->ops->read(disk, sb.inode_map_sz + 1, sb.block_map_sz, block_map);
      507:   76:    block_map_sz = sb.block_map_sz;
        -:   77:
        -:   78:    // printf("%d\n", block_map_sz);
        -:   79:    /* read inodes */
      507:   80:    inode_region = malloc(sb.inode_region_sz * FS_BLOCK_SIZE);
      507:   81:    int inode_region_pos = 1 + sb.inode_map_sz + sb.block_map_sz;
      507:   82:    disk->ops->read(disk, inode_region_pos, sb.inode_region_sz, inode_region);
        -:   83:    // printf("%d\n", sb.inode_region_sz);
      507:   84:    num_of_blocks = sb.num_blocks;
        -:   85:    // printf("%d\n", num_of_blocks);
        -:   86:
      507:   87:    return NULL;
        -:   88:}
        -:   89:
        -:   90:/* Note on path translation errors:
        -:   91: * In addition to the method-specific errors listed below, almost
        -:   92: * every method can return one of the following errors if it fails to
        -:   93: * locate a file or directory corresponding to a specified path.
        -:   94: *
        -:   95: * ENOENT - a component of the path is not present.
        -:   96: * ENOTDIR - an intermediate component of the path (e.g. 'b' in
        -:   97: *           /a/b/c) is not a directory
        -:   98: */
        -:   99:
        -:  100:/* note on splitting the 'path' variable:
        -:  101: * the value passed in by the FUSE framework is declared as 'const',
        -:  102: * which means you can't modify it. The standard mechanisms for
        -:  103: * splitting strings in C (strtok, strsep) modify the string in place,
        -:  104: * so you have to copy the string and then free the copy when you're
        -:  105: * done. One way of doing this:
        -:  106: *
        -:  107: *    char *_path = strdup(path);
        -:  108: *    int inum = translate(_path);
        -:  109: *    free(_path);
        -:  110: */
        -:  111:/* translate: return the inode number of given path */
     8053:  112:static int translate(const char *path) {
        -:  113:    /* split the path */
        -:  114:    char *_path;
     8053:  115:    _path = strdup(path);
        -:  116:    /* traverse to path */
        -:  117:    /* root father_inode */
     8053:  118:    int inode_num = 1;
        -:  119:    struct fs5600_inode *father_inode;
        -:  120:    struct fs5600_dirent *dir;
     8053:  121:    dir = malloc(FS_BLOCK_SIZE);
        -:  122:
     8053:  123:    struct fs5600_dirent dummy_dir = {
        -:  124:	.valid = 1,
        -:  125:	.isDir = 1,
        -:  126:	.inode = inode_num,
        -:  127:	.name = "/",
        -:  128:    };
     8053:  129:    struct fs5600_dirent *current_dir = &dummy_dir;
        -:  130:
        -:  131:    char *token;
     8053:  132:    char *delim = "/";
     8053:  133:    token = strtok(_path, delim);
     8053:  134:    int error = 0;
        -:  135:    /* traverse all the subsides */
        -:  136:    /* if found, return corresponding father_inode */
        -:  137:    /* else, return error */
    27403:  138:    while (token != NULL) {
    11619:  139:        if (current_dir->valid == 0) {
    #####:  140:	        error = -ENOENT;
    #####:  141:            break;
        -:  142:	    }
    11619:  143:	    if (current_dir->isDir == 0) {
    #####:  144:	        if (token != NULL) {
    #####:  145:                error = -ENOTDIR;
        -:  146:            }
    #####:  147:            break;
        -:  148:	    }
    11619:  149:	    father_inode = &inode_region[inode_num];
    11619:  150:	    int block_pos = father_inode->direct[0];
    11619:  151:	    disk->ops->read(disk, block_pos, 1, dir);
        -:  152:	    int i;
    11619:  153:	    int found = 0;
   383427:  154:	    for (i = 0; i < 32; i++) {
   371808:  155:            if (strcmp(dir[i].name, token) == 0 && dir[i].valid == 1) {
    11297:  156:                found = 1;
    11297:  157:                inode_num = dir[i].inode;
    11297:  158:                current_dir = &dir[i];
        -:  159:            }
        -:  160:	    }
    11619:  161:	    if (found == 0) {
      322:  162:            error = -ENOENT;
      322:  163:            break;
        -:  164:	    }
    11297:  165:        token = strtok(NULL, delim);
        -:  166:    }
        -:  167:
     8053:  168:    free(dir);
     8053:  169:    free(_path);
     8053:  170:    if (error != 0) {
      322:  171:        return error;
        -:  172:    }
     7731:  173:    return inode_num;
        -:  174:}
        -:  175:int trancate_path (const char *path, char **trancated_path);
        -:  176:/* trancate the last token from path
        -:  177: * return 1 if succeed, 0 if not*/
      286:  178:int trancate_path (const char *path, char **trancated_path) {
      286:  179:    int i = strlen(path) - 1;
        -:  180:    // strip the tailling '/'
        -:  181:    // deal with '///' case
      311:  182:    for (; i >= 0; i--) {
      286:  183:        if (path[i] != '/') {
      261:  184:            break;
        -:  185:        }
        -:  186:    }
     4706:  187:    for (; i >= 0; i--) {
     4681:  188:    	if (path[i] == '/') {
      261:  189:            *trancated_path = (char*)malloc(sizeof(char) * (i + 2));
      261:  190:            memcpy(*trancated_path, path, i + 1);
      261:  191:            (*trancated_path)[i + 1] = '\0';
      261:  192:            return 1;
        -:  193:    	}
        -:  194:    }
       25:  195:    return 0;
        -:  196:}
        -:  197:
      435:  198:static void set_attr(struct fs5600_inode inode, struct stat *sb) {
        -:  199:    /* set every other bit to zero */
      435:  200:    memset(sb, 0, sizeof(struct stat));
      435:  201:    sb->st_mode = inode.mode;
      435:  202:    sb->st_uid = inode.uid;
      435:  203:    sb->st_gid = inode.gid;
      435:  204:    sb->st_size = inode.size;
      435:  205:    sb->st_blocks = 1 + ((inode.size - 1) / FS_BLOCK_SIZE);
      435:  206:    sb->st_nlink = 1;
      435:  207:    sb->st_atime = inode.mtime;
      435:  208:    sb->st_ctime = inode.ctime;
      435:  209:    sb->st_mtime = inode.mtime;
      435:  210:}
        -:  211:
        -:  212:/* getattr - get file or directory attributes. For a description of
        -:  213: *  the fields in 'struct stat', see 'man lstat'.
        -:  214: *
        -:  215: * Note - fields not provided in CS5600fs are:
        -:  216: *    st_nlink - always set to 1
        -:  217: *    st_atime, st_ctime - set to same value as st_mtime
        -:  218: *
        -:  219: * errors - path translation, ENOENT
        -:  220: */
      506:  221:static int fs_getattr(const char *path, struct stat *sb)
        -:  222:{
      506:  223:    fs_init(NULL);
      506:  224:    int inum = translate(path);
      506:  225:    if (inum == -ENOENT || inum == -ENOTDIR) {
      204:  226:    	return -ENOENT;
        -:  227:    }
        -:  228:
      302:  229:    struct fs5600_inode inode = inode_region[inum];
      302:  230:    set_attr(inode, sb);
        -:  231:    /* what should I return if succeeded?
        -:  232:     success (0) */
      302:  233:    return 0;
        -:  234:}
        -:  235:
        -:  236:/* check whether this inode is a directory */
       29:  237:int inode_is_dir(int father_inum, int inum) {
        -:  238:    struct fs5600_inode *inode;
        -:  239:    struct fs5600_dirent *dir;
       29:  240:    dir = malloc(FS_BLOCK_SIZE);
        -:  241:
       29:  242:    inode = &inode_region[father_inum];
       29:  243:    int block_pos = inode->direct[0];
       29:  244:    disk->ops->read(disk, block_pos, 1, dir);
        -:  245:    int i;
      514:  246:    for (i = 0; i < 32; i++) {
      514:  247:	if (dir[i].valid == 0) {
      259:  248:	    continue;
        -:  249:	}
      255:  250:	if (dir[i].inode == inum) {
       29:  251:        int result = dir[i].inode;
       29:  252:        free(dir);
       29:  253:	    return result;
        -:  254:	}
        -:  255:    }
    #####:  256:    free(dir);
    #####:  257:    return 0;
        -:  258:}
        -:  259:/* readdir - get directory contents.
        -:  260: *
        -:  261: * for each entry in the directory, invoke the 'filler' function,
        -:  262: * which is passed as a function pointer, as follows:
        -:  263: *     filler(ptr, <name>, <statbuf>, 0)
        -:  264: * where <statbuf> is a struct stat, just like in getattr.
        -:  265: *
        -:  266: * Errors - path resolution, ENOTDIR, ENOENT
        -:  267: */
       54:  268:static int fs_readdir(const char *path, void *ptr, fuse_fill_dir_t filler,
        -:  269:		       off_t offset, struct fuse_file_info *fi)
        -:  270:{
        -:  271:    char *trancated_path;
       54:  272:    int father_inum = 0;
        -:  273:    // if succeeded in trancating path
       54:  274:    if (trancate_path(path, &trancated_path)) {
       29:  275:        father_inum = translate(trancated_path);
        -:  276:    }
        -:  277:
       54:  278:    int inum = translate(path);
       54:  279:    if (inum == -ENOTDIR || inum == -ENOENT) {
    #####:  280:    	return inum;
        -:  281:    }
        -:  282:
       54:  283:    if (father_inum != 0 && !inode_is_dir(father_inum, inum)) {
    #####:  284:    	return -ENOTDIR;
        -:  285:    }
        -:  286:
        -:  287:
        -:  288:    struct fs5600_inode *inode;
        -:  289:    struct fs5600_dirent *dir;
       54:  290:    inode = &inode_region[inum];
        -:  291:    // check is dir
       54:  292:    if(!S_ISDIR(inode->mode)) {
    #####:  293:        return -ENOTDIR;
        -:  294:    }
        -:  295:
       54:  296:    dir = malloc(FS_BLOCK_SIZE);
       54:  297:    int block_pos = inode->direct[0];
       54:  298:    disk->ops->read(disk, block_pos, 1, dir);
        -:  299:    int curr_inum;
        -:  300:    struct fs5600_inode curr_inode;
        -:  301:
        -:  302:    struct stat sb;
        -:  303:
        -:  304:    int i;
     1782:  305:    for (i = 0; i < 32; i++) {
     1728:  306:    	if (dir[i].valid == 0) {
     1595:  307:    	    continue;
        -:  308:    	}
        -:  309:
      133:  310:    	curr_inum = dir[i].inode;
      133:  311:        curr_inode = inode_region[curr_inum];
      133:  312:    	set_attr(curr_inode, &sb);
      133:  313:    	filler(ptr, dir[i].name, &sb, 0);
        -:  314:    }
       54:  315:    free(dir);
       54:  316:    return 0;
        -:  317:}
        -:  318:
        -:  319:int find_free_dirent_num(struct fs5600_inode *inode);
        -:  320:
        -:  321:int find_free_inode_map_bit();
        -:  322:
        -:  323:static char *get_name(char *path);
        -:  324:static void strip(char *path);
        -:  325:
        -:  326:void update_inode(int inum);
        -:  327:
        -:  328:/* mknod - create a new file with specified permissions
        -:  329:*
        -:  330:* Errors - path resolution, EEXIST
        -:  331:*          in particular, for mknod("/a/b/c") to succeed,
        -:  332:*          "/a/b" must exist, and "/a/b/c" must not.
        -:  333:*
        -:  334:* If a file or directory of this name already exists, return -EEXIST.
        -:  335:* If this would result in >32 entries in a directory, return -ENOSPC
        -:  336:* if !S_ISREG(mode) [i.e. 'mode' specifies a device special
        -:  337:* file or other non-file object] then return -EINVAL
        -:  338:*/
       84:  339:static int fs_mknod(const char *path, mode_t mode, dev_t dev)
        -:  340:{
       84:  341:    if (!S_ISREG(mode)) {
    #####:  342:        return -EINVAL;
        -:  343:    }
        -:  344:    // check father dir exist
        -:  345:    char *father_path;
       84:  346:    if (!trancate_path(path, &father_path)) {
        -:  347:        // this means there is no nod to make, path is "/"
    #####:  348:        return -1;
        -:  349:    }
       84:  350:    int dir_inum = translate(father_path);
       84:  351:    if (dir_inum == -ENOENT || dir_inum == -ENOTDIR) {
    #####:  352:        return -EEXIST;
        -:  353:    }
        -:  354:    // check if dest file exists
       84:  355:    int inum = translate(path);
       84:  356:    if (inum > 0) {
    #####:  357:        return -EEXIST;
        -:  358:    }
        -:  359:    // check entries in father dir not excceed 32
       84:  360:    struct fs5600_inode *father_inode = &inode_region[dir_inum];
       84:  361:    int free_dirent_num = find_free_dirent_num(father_inode);
       84:  362:    if(free_dirent_num < 0) {
        1:  363:        return -ENOSPC;
        -:  364:    }
        -:  365:
        -:  366:    // here allocate inode region, i.e. set inode region bitmap
        -:  367:    time_t time_raw_format;
       83:  368:    time( &time_raw_format );
      249:  369:    struct fs5600_inode new_inode = {
       83:  370:            .uid = getuid(),
       83:  371:            .gid = getgid(),
        -:  372:            .mode = mode,
        -:  373:            .ctime = time_raw_format,
        -:  374:            .mtime = time_raw_format,
        -:  375:            .size = 0,
        -:  376:    };
       83:  377:    int free_inum = find_free_inode_map_bit();
       83:  378:    if (free_inum < 0) {
    #####:  379:        return -ENOSPC;
        -:  380:    }
       83:  381:    FD_SET(free_inum, inode_map);
       83:  382:    update_bitmap();
        -:  383:
        -:  384:    // write father_inode to the allocated pos in father_inode region
       83:  385:    memcpy(&inode_region[free_inum], &new_inode, sizeof(struct fs5600_inode));
       83:  386:    update_inode(free_inum);
        -:  387:
        -:  388:
        -:  389:    // set valid, isDir, father_inode, name in father father_inode dirent
        -:  390:    // then write dirent to image
       83:  391:    char *_path = strdup(path);
       83:  392:    char *tmp_name = get_name(_path);
       83:  393:    struct fs5600_dirent new_dirent = {
        -:  394:            .valid = 1,
        -:  395:            .isDir = 0,
        -:  396:            .inode = free_inum,
        -:  397:            .name = "",
        -:  398:    };
       83:  399:    assert(strlen(tmp_name) < 28);
       83:  400:    strncpy(new_dirent.name, tmp_name, strlen(tmp_name));
       83:  401:    new_dirent.name[strlen(tmp_name)] = '\0';
        -:  402:
       83:  403:    struct fs5600_dirent *dir_blk = (struct fs5600_dirent *)calloc(BLOCK_SIZE / sizeof(int), sizeof(int));
       83:  404:    disk->ops->read(disk, (father_inode->direct)[0], 1, dir_blk);
       83:  405:    memcpy(&dir_blk[free_dirent_num], &new_dirent, sizeof(struct fs5600_dirent));
       83:  406:    disk->ops->write(disk, father_inode->direct[0], 1, dir_blk);
       83:  407:    free(dir_blk);
       83:  408:    free(_path);
       83:  409:    return 0;
        -:  410:}
        -:  411:
     7236:  412:void update_inode(int inum) {
     7236:  413:    int offset = 1 + inode_map_sz + block_map_sz + (inum / 16);
     7236:  414:    disk->ops->write(disk, offset, 1, &inode_region[inum - (inum % 16)]);
     7236:  415:}
        -:  416:
       30:  417:static void strip(char *path) {
       30:  418:	if (path[strlen(path) - 1] == '/') {
    #####:  419:		path[strlen(path) - 1] = '\0';
        -:  420:	}
       30:  421:}
      229:  422:static char *get_name(char *path) {
      229:  423:    int i = strlen(path) - 1;
     4064:  424:    for (; i >= 0; i--) {
     4064:  425:        if (path[i] == '/') {
      229:  426:            i++;
      229:  427:            break;
        -:  428:        }
        -:  429:    }
      229:  430:    char *result = &path[i];
      229:  431:    return result;
        -:  432:}
        -:  433:
      115:  434:int find_free_inode_map_bit() {// find a free inode_region
      115:  435:    int inode_capacity = inode_map_sz * FS_BLOCK_SIZE * 8;
        -:  436:    int i;
     2731:  437:    for (i = 2; i < inode_capacity; i++) {
     2731:  438:        if (!FD_ISSET(i, inode_map)) {
      115:  439:            return i;
        -:  440:        }
        -:  441:    }
    #####:  442:    return -ENOSPC;
        -:  443:}
        -:  444:
      117:  445:int find_free_dirent_num(struct fs5600_inode *inode) {
      117:  446:    struct fs5600_dirent *dir = (struct fs5600_dirent *)malloc(BLOCK_SIZE);
      117:  447:    disk->ops->read(disk, (inode->direct)[0], 1, dir);
        -:  448:
      117:  449:    int free_dirent_num = -1;
        -:  450:    int i;
     1234:  451:    for (i = 0; i < 32; i++) {
     1232:  452:        if (!dir[i].valid) {
      115:  453:            free_dirent_num = i;
      115:  454:            break;
        -:  455:        }
        -:  456:    }
      117:  457:    free(dir);
      117:  458:    return free_dirent_num;
        -:  459:}
        -:  460:
        -:  461:int find_free_block_number();
        -:  462:/* mkdir - create a directory with the given mode.
        -:  463: * Errors - path resolution, EEXIST
        -:  464: * Conditions for EEXIST are the same as for create.
        -:  465: * If this would result in >32 entries in a directory, return -ENOSPC
        -:  466: *
        -:  467: * Note that you may want to combine the logic of fs_mknod and
        -:  468: * fs_mkdir.
        -:  469: */
       33:  470:static int fs_mkdir(const char *path, mode_t mode)
        -:  471:{
       33:  472:    mode = mode | S_IFDIR;
       33:  473:    if (!S_ISDIR(mode)) {
    #####:  474:        return -EINVAL;
        -:  475:    }
        -:  476:    /*check father dir exist*/
        -:  477:    char *father_path;
       33:  478:    if (!trancate_path(path, &father_path)) {
        -:  479:        // this means there is no nod to make, path is "/"
    #####:  480:        return -1;
        -:  481:    }
       33:  482:    int dir_inum = translate(father_path);
       33:  483:    if (dir_inum == -ENOENT || dir_inum == -ENOTDIR) {
    #####:  484:        return -EEXIST;
        -:  485:    }
        -:  486:
        -:  487:
        -:  488:    // check if dest file exists
       33:  489:    int inum = translate(path);
       33:  490:    if (inum > 0) {
    #####:  491:        return -EEXIST;
        -:  492:    }
        -:  493:    // check entries in father dir not excceed 32
       33:  494:    struct fs5600_inode *father_inode = &inode_region[dir_inum];
       33:  495:    int free_dirent_num = find_free_dirent_num(father_inode);
       33:  496:    if(free_dirent_num < 0) {
        1:  497:        return -ENOSPC;
        -:  498:    }
        -:  499:    //check father is a dir
       32:  500:    if (!S_ISDIR(father_inode->mode)) {
    #####:  501:        return -EEXIST;
        -:  502:    }
        -:  503:
        -:  504:    // here allocate inode region, i.e. set inode region bitmap
        -:  505:    time_t time_raw_format;
       32:  506:    time( &time_raw_format );
       96:  507:    struct fs5600_inode new_inode = {
       32:  508:            .uid = getuid(),
       32:  509:            .gid = getgid(),
        -:  510:            .mode = mode,
        -:  511:            .ctime = time_raw_format,
        -:  512:            .mtime = time_raw_format,
        -:  513:            .size = 0,
        -:  514:            .direct = {0, 0, 0, 0, 0, 0},
        -:  515:    };
       32:  516:    int free_blk_num = find_free_block_number();
       32:  517:    FD_SET(free_blk_num, block_map);
       32:  518:    update_bitmap();
       32:  519:    new_inode.direct[0] = free_blk_num;
       32:  520:    int *clear_block = (int *)calloc(BLOCK_SIZE, sizeof(int));
       32:  521:    disk->ops->write(disk, new_inode.direct[0], 1, clear_block);
       32:  522:    int free_inum = find_free_inode_map_bit();
       32:  523:    if (free_inum < 0) {
    #####:  524:        free(clear_block);
    #####:  525:        return -ENOSPC;
        -:  526:    }
       32:  527:    FD_SET(free_inum, inode_map);
       32:  528:    update_bitmap();
        -:  529:
        -:  530:    // write father_inode to the allocated pos in father_inode region
       32:  531:    memcpy(&inode_region[free_inum], &new_inode, sizeof(struct fs5600_inode));
       32:  532:    update_inode(free_inum);
        -:  533:
        -:  534:
        -:  535:    // set valid, isDir, father_inode, name in father father_inode dirent
        -:  536:    // then write dirent to image
       32:  537:    char *_path = strdup(path);
       32:  538:    char *tmp_name = get_name(_path);
       32:  539:    struct fs5600_dirent new_dirent = {
        -:  540:            .valid = 1,
        -:  541:            .isDir = 1,
        -:  542:            .inode = free_inum,
        -:  543:            .name = "",
        -:  544:    };
       32:  545:    assert(strlen(tmp_name) < 28);
       32:  546:    memcpy(new_dirent.name, tmp_name, strlen(tmp_name));
        -:  547:
       32:  548:    struct fs5600_dirent *dir_blk = (struct fs5600_dirent *)malloc(BLOCK_SIZE);
       32:  549:    disk->ops->read(disk, (father_inode->direct)[0], 1, dir_blk);
       32:  550:    memcpy(&dir_blk[free_dirent_num], &new_dirent, sizeof(struct fs5600_dirent));
       32:  551:    disk->ops->write(disk, father_inode->direct[0], 1, dir_blk);
        -:  552:
       32:  553:    free(clear_block);
       32:  554:    free(dir_blk);
       32:  555:    free(_path);
       32:  556:    return 0;
        -:  557:    // return -EOPNOTSUPP;
        -:  558:}
        -:  559:
        -:  560:void truncate_2nd_level(int h1t_root_blk_num);
        -:  561:
        -:  562:void truncate_3rd_level(int h2t_root_blk_num);
        -:  563:
        -:  564:/* truncate - truncate file to exactly 'len' bytes
        -:  565: * Errors - path resolution, ENOENT, EISDIR, EINVAL
        -:  566: *    return EINVAL if len > 0.
        -:  567: */
       87:  568:static int fs_truncate(const char *path, off_t len)
        -:  569:{
        -:  570:    /* We'll cheat by only implementing this for the case of len==0,
        -:  571:     * and an error otherwise, as 99.99% of the time that's how
        -:  572:     * truncate is used.
        -:  573:     */
       87:  574:    if (len != 0)
    #####:  575:	return -EINVAL;		/* invalid argument */
        -:  576:
       87:  577:    int inum = translate(path);
       87:  578:    if (inum == -ENOENT || inum == -ENOTDIR) {
    #####:  579:        return -ENOENT;
        -:  580:    }
       87:  581:    struct fs5600_inode *inode = &inode_region[inum];
       87:  582:    if  (S_ISDIR(inode->mode)) {
    #####:  583:        return -EISDIR;
        -:  584:    }
        -:  585:
        -:  586:    // clear the block bit map of this inode
        -:  587:    int temp_blk_num;
        -:  588:    int i;
      350:  589:    for (i = 0; i < N_DIRECT; i++) {
      311:  590:        temp_blk_num = inode->direct[i];
      311:  591:        inode->direct[i] = 0;
      311:  592:        if (temp_blk_num != 0) {
      263:  593:            FD_CLR(temp_blk_num, block_map);
      263:  594:            update_bitmap();
        -:  595:        } else {
       48:  596:            break;
        -:  597:        }
        -:  598:    }
       87:  599:    if (inode->size > N_DIRECT * BLOCK_SIZE) {
       39:  600:        truncate_2nd_level(inode->indir_1);
        -:  601:    }
        -:  602:
       87:  603:    if (inode->size > (BLOCK_SIZE / 4) * BLOCK_SIZE + N_DIRECT * BLOCK_SIZE) {
       18:  604:        truncate_3rd_level(inode->indir_2);
        -:  605:    }
        -:  606:
        -:  607:    // set the size of inode as 0
       87:  608:    inode_region[inum].size = 0;
       87:  609:    inode_region[inum].indir_1 = 0;
       87:  610:    inode_region[inum].indir_2 = 0;
       87:  611:    update_inode(inum);
       87:  612:    return 0;
        -:  613:}
        -:  614:
        -:  615:
       75:  616:void truncate_2nd_level(int h1t_root_blk_num) {
        -:  617:    int h1t_blk[256];
       75:  618:    disk->ops->read(disk, h1t_root_blk_num, 1, h1t_blk);
        -:  619:    int i;
    14269:  620:    for (i = 0; i < 256; ++i) {
    14233:  621:        int temp_blk_num = h1t_blk[i];
    14233:  622:        if (temp_blk_num != 0) {
    14194:  623:            FD_CLR(temp_blk_num, block_map);
        -:  624:        } else {
       39:  625:            break;
        -:  626:        }
        -:  627:    }
       75:  628:    FD_CLR(h1t_root_blk_num, block_map);
       75:  629:    update_bitmap();
       75:  630:}
        -:  631:
       18:  632:void truncate_3rd_level(int h2t_root_blk_num) {
       18:  633:    sleep(0.1);
        -:  634:    int h2t_blk[256];
       18:  635:    disk->ops->read(disk, h2t_root_blk_num, 1, h2t_blk);
        -:  636:    int i;
       54:  637:    for (i = 0; i < 256; ++i) {
       54:  638:        int temp_blk_num = h2t_blk[i];
       54:  639:        if (temp_blk_num == 0) {
       18:  640:            break;
        -:  641:        }
       36:  642:        truncate_2nd_level(h2t_blk[i]);
        -:  643:    }
       18:  644:    FD_CLR(h2t_root_blk_num, block_map);
       18:  645:    update_bitmap();
       18:  646:}
        -:  647:
        -:  648:/* unlink - delete a file
        -:  649: *  Errors - path resolution, ENOENT, EISDIR
        -:  650: * Note that you have to delete (i.e. truncate) all the data.
        -:  651: */
       82:  652:static int fs_unlink(const char *path)
        -:  653:{
       82:  654:    int inum = translate(path);
       82:  655:    if (inum == -ENOENT || inum == -ENOTDIR) {
    #####:  656:        return -ENOENT;
        -:  657:    }
       82:  658:    struct fs5600_inode *inode = &inode_region[inum];
       82:  659:    if  (S_ISDIR(inode->mode)) {
    #####:  660:        return -EISDIR;
        -:  661:    }
        -:  662:
        -:  663:    // truncate all the data
       82:  664:    int truncate_result = fs_truncate(path, 0);
       82:  665:    if (truncate_result != 0) {
    #####:  666:        return truncate_result;
        -:  667:    }
        -:  668:
        -:  669:    char *father_path;
       82:  670:    trancate_path(path, &father_path);
       82:  671:    int father_inum = translate(father_path);
       82:  672:    free(father_path);
       82:  673:    struct fs5600_inode *father_inode = &inode_region[father_inum];
        -:  674:
        -:  675:
        -:  676:    // remove inode, i.e. clear inode_map corresponding bit
       82:  677:    FD_CLR(inum, inode_map);
       82:  678:    update_bitmap();
        -:  679:
        -:  680:    // remove entry from father dir
       82:  681:    char *_path = strdup(path);
       82:  682:    char *name = get_name(_path);
        -:  683:
       82:  684:    struct fs5600_dirent *father_dir = malloc(FS_BLOCK_SIZE);
       82:  685:    disk->ops->read(disk, father_inode->direct[0], 1, father_dir);
       82:  686:    int found = 0;
        -:  687:    int i;
     2706:  688:    for (i = 0; i < 32; ++i) {
     2624:  689:        if (strcmp(father_dir[i].name, name) == 0) {
       82:  690:            if (father_dir[i].valid == 1 ) {
       82:  691:                father_dir[i].valid = 0;
       82:  692:                found = 1;
        -:  693:            }
        -:  694:        }
        -:  695:    }
       82:  696:    disk->ops->write(disk, father_inode->direct[0], 1, father_dir);
       82:  697:    if (!found) {
    #####:  698:        return -ENOENT;
        -:  699:    }
       82:  700:    free(father_dir);
       82:  701:    free(_path);
       82:  702:    return 0;
        -:  703:}
        -:  704:
        -:  705:/* rmdir - remove a directory
        -:  706: *  Errors - path resolution, ENOENT, ENOTDIR, ENOTEMPTY
        -:  707: * Remember that you have to check to make sure that the directory is
        -:  708: * empty
        -:  709: */
       31:  710:static int fs_rmdir(const char *path)
        -:  711:{
        -:  712:    // check dir is dir
       31:  713:    int inum = translate(path);
       31:  714:    if (inum == -ENOENT || inum == -ENOTDIR) {
    #####:  715:        return -ENOENT;
        -:  716:    }
       31:  717:    struct fs5600_inode *inode = &inode_region[inum];
       31:  718:    if  (S_ISREG(inode->mode)) {
    #####:  719:        return -ENOTDIR;
        -:  720:    }
        -:  721:
        -:  722:    // check not root dir
        -:  723:    char *father_path;
       31:  724:    int succeed = trancate_path(path, &father_path);
       31:  725:    if (!succeed) {
    #####:  726:        printf("Attempting to delete root directory");
    #####:  727:        assert(0);
        -:  728:    }
        -:  729:
        -:  730:    // check dir is empty
       31:  731:    struct fs5600_dirent *dirent = malloc(FS_BLOCK_SIZE);
       31:  732:    disk->ops->read(disk, inode->direct[0], 1, dirent);
       31:  733:    int empty = 1;
        -:  734:    int i;
      994:  735:    for (i = 0; i < 32; ++i) {
      964:  736:        if (dirent[i].valid) {
        1:  737:            empty = 0;
        1:  738:            break;
        -:  739:        }
        -:  740:    }
       31:  741:    free(dirent);
       31:  742:    if (!empty) {
        1:  743:        return -ENOTEMPTY;
        -:  744:    }
        -:  745:
        -:  746:    // block map remove the block of this dir
       30:  747:    FD_SET(inode->direct[0], inode_map);
       30:  748:    update_bitmap();
        -:  749:
        -:  750:    // inode map remove this dir
       30:  751:    FD_SET(inum, inode_map);
       30:  752:    update_bitmap();
        -:  753:
        -:  754:    // then unlink this dir
       30:  755:    char *_path = strdup(path);
       30:  756:    strip(_path);
       30:  757:    char *name = get_name(_path);
       30:  758:    int father_inum = translate(father_path);
       30:  759:    free(father_path);
       30:  760:    struct fs5600_inode *father_inode = &inode_region[father_inum];
       30:  761:    struct fs5600_dirent *father_dirent = malloc(FS_BLOCK_SIZE);
       30:  762:    disk->ops->read(disk, father_inode->direct[0], 1, father_dirent);
      990:  763:    for (i = 0; i < 32; ++i) {
      960:  764:        if (strcmp(father_dirent[i].name, name) == 0) {
       30:  765:            if (father_dirent[i].valid == 1 ) {
       30:  766:                father_dirent[i].valid = 0;
        -:  767:            }
        -:  768:        }
        -:  769:    }
       30:  770:    disk->ops->write(disk, father_inode->direct[0], 1, father_dirent);
        -:  771:
       30:  772:    free(_path);
       30:  773:    return -0;
        -:  774:}
        -:  775:
        -:  776:/* rename - rename a file or directory
        -:  777: * Errors - path resolution, ENOENT, EINVAL, EEXIST
        -:  778: *
        -:  779: * ENOENT - source does not exist
        -:  780: * EEXIST - destination already exists
        -:  781: * EINVAL - source and destination are not in the same directory
        -:  782: *
        -:  783: * Note that this is a simplified version of the UNIX rename
        -:  784: * functionality - see 'man 2 rename' for full semantics. In
        -:  785: * particular, the full version can move across directories, replace a
        -:  786: * destination file, and replace an empty directory with a full one.
        -:  787: */
        -:  788:
        -:  789: /*TODO: finished: compile succeeds, simple test passed, need more test*/
        1:  790:static int fs_rename(const char *src_path, const char *dst_path)
        -:  791:{
        -:  792:	/*check exists of src file and dst file*/
        -:  793:	int src_inum, dst_inum;
        1:  794:	src_inum = translate(src_path);
        1:  795:	dst_inum = translate(dst_path);
        1:  796:   	if (src_inum < 0)  {
    #####:  797:   		return -ENOENT;
        -:  798:   	}
        1:  799:   	if (dst_inum > 0) {
    #####:  800:   		return -EEXIST;
        -:  801:   	}
        -:  802:   	/*check exists of father dir*/
        -:  803:   	char *src_father_path;
        -:  804:   	char *dst_father_path;
        1:  805:   	if (!trancate_path(src_path, &src_father_path) || !trancate_path(dst_path, &dst_father_path)) {
    #####:  806:        free(src_father_path);
    #####:  807:        free(dst_father_path);
    #####:  808:        return -ENOENT;
        -:  809:   	}
        1:  810:   	if (strcmp(src_father_path, dst_father_path) != 0) {
    #####:  811:        free(src_father_path);
    #####:  812:        free(dst_father_path);
    #####:  813:   		return -EINVAL;
        -:  814:   	}
        -:  815:   	int father_inum;
        1:  816:   	if (!(father_inum = translate(src_father_path))) {
    #####:  817:        free(src_father_path);
    #####:  818:        free(dst_father_path);
    #####:  819:   		return father_inum;
        -:  820:   	}
        -:  821:   	/*get the name of the src and dst path*/
        1:  822:   	char *_src_path = strdup(src_path);
        1:  823:   	char *src_name = get_name(_src_path);
        1:  824:   	char *_dst_path = strdup(dst_path);
        1:  825:   	char *dst_name = get_name(_dst_path);
        -:  826:
        -:  827:   	/*load dirent block to memory to search src file name*/
        -:  828:   	struct fs5600_inode *father_inode;
        -:  829:    struct fs5600_dirent *dir;
        1:  830:    dir = malloc(FS_BLOCK_SIZE);
        -:  831:
        1:  832:    father_inode = &inode_region[father_inum];
        1:  833:    int block_pos = father_inode->direct[0];
        1:  834:    disk->ops->read(disk, block_pos, 1, dir);
        -:  835:    int i;
        -:  836:    /*traverse the drient block to find the dirent with the same name*/
       33:  837:    for (i = 0;i < 32; i++) {
       32:  838:    	if (dir[i].valid == 1 && strcmp(dir[i].name, src_name) == 0) {
        1:  839:    		strncpy(dir[i].name, dst_name, strlen(dst_name));
        1:  840:    		dir[i].name[strlen(dst_name)] = '\0';
        1:  841:    		disk->ops->write(disk, block_pos, 1, dir);
        -:  842:    	}
        -:  843:    }
        1:  844:    free(_src_path);
        1:  845:    free(_dst_path);
        1:  846:   	free(src_father_path);
        1:  847:   	free(dst_father_path);
        1:  848:    return 0;
        -:  849:}
        -:  850:
        -:  851:/* chmod - change file permissions
        -:  852: *
        -:  853: * Errors - path resolution, ENOENT.
        -:  854: */
        -:  855: /*TODO: finished: simple test passed but need more test*/
        1:  856:static int fs_chmod(const char *path, mode_t mode)
        -:  857:{
        1:  858:    int inum = translate(path);
        1:  859:    if (inum < 0) {
    #####:  860:    	return inum;
        -:  861:    }
        -:  862:    struct fs5600_inode *inode;
        1:  863:    inode = &inode_region[inum];
        1:  864:    inode->mode = mode;
        1:  865:    update_inode(inum);
        1:  866:    return 0;
        -:  867:}
        -:  868:
        -:  869:/* utime - change access and modification times (see 'man utime')
        -:  870: * Errors - path resolution, ENOENT.
        -:  871: * The utimbuf structure has two fields:
        -:  872: *   time_t actime;  // access time - ignore
        -:  873: *   time_t modtime; // modification time, same format as in inode
        -:  874: */
       30:  875:int fs_utime(const char *path, struct utimbuf *ut)
        -:  876:{
       30:  877:    int inum = translate(path);
       30:  878:    if (inum < 0) {
    #####:  879:    	return inum;
        -:  880:    }
        -:  881:    struct fs5600_inode *inode;
       30:  882:    inode = &inode_region[inum];
       30:  883:    inode->mtime = ut->modtime;
       30:  884:    update_inode(inum);
       30:  885:    return 0;
        -:  886:}
        -:  887:
        -:  888:
        -:  889:/*
        -:  890: * given block number, offset, length and return buffer, load corresponding data into buffer
        -:  891: *
        -:  892: */
        -:  893:static int fs_read_block(int blknum, int offset, int len, char *buf);
        -:  894:
        -:  895:// return the read in length
        -:  896:static int fs_read_1st_level(const struct fs5600_inode *inode, off_t offset, size_t len, char *buf);
        -:  897:// return the read in length
        -:  898:static int fs_read_2nd_level(size_t root_blk, int offset, int len, char *buf);
        -:  899:static int fs_read_3rd_level(size_t root_blk, int offset, int len, char *buf);
        -:  900:
        -:  901:/* read - read data from an open file.
        -:  902: * should return exactly the number of bytes requested, except:
        -:  903: *   - if offset >= file len, return 0
        -:  904: *   - if offset+len > file len, return bytes from offset to EOF
        -:  905: *   - on error, return <0
        -:  906: * Errors - path resolution, ENOENT, EISDIR
        -:  907: */
      199:  908:static int fs_read(const char *path, char *buf, size_t len, off_t offset,
        -:  909:                   struct fuse_file_info *fi)
        -:  910:{
        -:  911:    /*first get the inode
        -:  912:    check it is valid
        -:  913:    check it is file*/
        -:  914:
      199:  915:    int tmp_offset = offset;
      199:  916:    int inum = translate(path);
      199:  917:    if (inum == -ENOENT || inum == -ENOTDIR) {
    #####:  918:        return -ENOENT;
        -:  919:    }
      199:  920:    const struct fs5600_inode *inode = &inode_region[inum];
      199:  921:    if(!S_ISREG(inode->mode)) {
    #####:  922:        return -EISDIR;
        -:  923:    }
      199:  924:    int size = inode->size;
      199:  925:    if (tmp_offset >= size) {
       11:  926:        return 0;
        -:  927:    }
      188:  928:    if (tmp_offset + len > size) {
       62:  929:        len = size - tmp_offset;
        -:  930:    }
      188:  931:    int tmp_len = len;
      188:  932:    if (tmp_offset < file_in_inode_sz) {
       62:  933:        int read_len = fs_read_1st_level(inode, tmp_offset, tmp_len, buf);
       62:  934:        tmp_offset += read_len;
       62:  935:        tmp_len -= read_len;
       62:  936:        buf += read_len;
        -:  937:    }
      365:  938:    if (tmp_offset >= file_in_inode_sz &&
      177:  939:        tmp_offset < file_in_inode_sz + file_1st_level_sz) {
      123:  940:        int read_len = fs_read_2nd_level(inode->indir_1, tmp_offset, tmp_len, buf);
      123:  941:        tmp_offset += read_len;
      123:  942:        tmp_len -= read_len;
      123:  943:        buf += read_len;
        -:  944:    }
      260:  945:    if (tmp_offset >= file_in_inode_sz + file_1st_level_sz &&
       72:  946:        tmp_offset <= file_in_inode_sz + file_1st_level_sz + file_2nd_level_sz) {
       72:  947:        int read_len = fs_read_3rd_level(inode->indir_2, tmp_offset, tmp_len, buf);
       72:  948:        tmp_offset += read_len;
       72:  949:        tmp_len -= read_len;
       72:  950:        buf += read_len;
        -:  951:    }
      188:  952:    return tmp_offset - offset;
        -:  953:}
        -:  954:/*
        -:  955:*
        -:  956:*/
       62:  957:static int fs_read_1st_level(const struct fs5600_inode *inode, off_t offset, size_t len, char *buf) {
       62:  958:    int read_length = 0;
       62:  959:    int block_direct = offset / BLOCK_SIZE;
       62:  960:    int temp_len = len;
        -:  961:    int in_blk_len;
       62:  962:    int in_blk_offset = offset % BLOCK_SIZE;
      412:  963:    for (; block_direct < N_DIRECT && temp_len > 0; in_blk_offset = 0, block_direct++) {
      350:  964:        if (temp_len + in_blk_offset > BLOCK_SIZE) {
      339:  965:            in_blk_len = BLOCK_SIZE - in_blk_offset;
      339:  966:            temp_len -= in_blk_len;
        -:  967:        } else {
       11:  968:            in_blk_len = temp_len;
       11:  969:            temp_len = 0;
        -:  970:        }
      350:  971:        if (inode->direct[block_direct] == 0) {
    #####:  972:            break;
        -:  973:        }
      350:  974:        fs_read_block(inode->direct[block_direct], in_blk_offset, in_blk_len, buf);
      350:  975:        buf += in_blk_len;
      350:  976:        read_length += in_blk_len;
        -:  977:    }
       62:  978:    return read_length;
        -:  979:}
        -:  980:
      213:  981:static int fs_read_2nd_level(size_t root_blk, int offset, int len, char *buf){
      213:  982:    int read_length = 0;
      213:  983:    int h1t_offset = offset - file_in_inode_sz; // height 1 tree offset
      213:  984:    int block_direct = h1t_offset / BLOCK_SIZE;
      213:  985:    int temp_len = len;
        -:  986:    int in_blk_len;
      213:  987:    int in_blk_offset = h1t_offset % BLOCK_SIZE;
        -:  988:    int h1t_blk[256];
      213:  989:    disk->ops->read(disk, root_blk, 1, h1t_blk);
        -:  990:
    15391:  991:    for (; block_direct < 256 && temp_len > 0; in_blk_offset = 0, block_direct++) {
    15178:  992:        if (temp_len + in_blk_offset > BLOCK_SIZE) {
    14983:  993:            in_blk_len = BLOCK_SIZE - in_blk_offset;
    14983:  994:            temp_len -= in_blk_len;
        -:  995:        } else {
      195:  996:            in_blk_len = temp_len;
      195:  997:            temp_len = 0;
        -:  998:        }
    15178:  999:        if (h1t_blk[block_direct] == 0) {
    #####: 1000:            break;
        -: 1001:        }
    15178: 1002:        fs_read_block(h1t_blk[block_direct], in_blk_offset, in_blk_len, buf);
    15180: 1003:        buf += in_blk_len;
    15180: 1004:        read_length += in_blk_len;
        -: 1005:    }
      213: 1006:    return read_length;
        -: 1007:}
        -: 1008:
       72: 1009:static int fs_read_3rd_level(size_t root_blk, int offset, int len, char *buf){
       72: 1010:    int read_length = 0;
       72: 1011:    int h2t_offset = offset - file_1st_level_sz - file_in_inode_sz;// height 2 tree offset
       72: 1012:    int block_direct = h2t_offset / file_1st_level_sz;
       72: 1013:    int temp_len = len;
        -: 1014:    int in_blk_len;
       72: 1015:    int in_blk_offset = h2t_offset % file_1st_level_sz;
        -: 1016:
        -: 1017:
        -: 1018:    int h2t_blk[256];
       72: 1019:    disk->ops->read(disk, root_blk, 1, h2t_blk);
        -: 1020:
      162: 1021:    for (; block_direct < 256 && temp_len > 0; in_blk_offset = 0, block_direct++) {
       90: 1022:        if (temp_len + in_blk_offset > file_1st_level_sz) {
       18: 1023:            in_blk_len = file_1st_level_sz - in_blk_offset;
       18: 1024:            temp_len -= in_blk_len;
        -: 1025:        } else {
       72: 1026:            in_blk_len = temp_len;
       72: 1027:            temp_len = 0;
        -: 1028:        }
       90: 1029:        fs_read_2nd_level(h2t_blk[block_direct], in_blk_offset + file_in_inode_sz, in_blk_len, buf);
       90: 1030:        buf += in_blk_len;
       90: 1031:        read_length += in_blk_len;
        -: 1032:    }
       72: 1033:    return read_length;
        -: 1034:}
        -: 1035:
    15530: 1036:static int fs_read_block(int blknum, int offset, int len, char *buf) {
    15530: 1037:    assert(blknum > 0);
    15530: 1038:    char *blk = (char*) malloc(BLOCK_SIZE);
        -: 1039:
        -: 1040:
    15530: 1041:    disk->ops->read(disk, blknum, 1, blk);
    15526: 1042:    char *blk_ptr = blk;
    15526: 1043:    blk_ptr += offset;
    15526: 1044:    memcpy(buf, blk_ptr, len);
    15526: 1045:    free(blk);
    15526: 1046:    return 0;
        -: 1047:}
        -: 1048:static int fs_write_1st_level(int inode, off_t offset, size_t len, const char *buf);
        -: 1049:static int fs_write_2nd_level(size_t root_blk, int offset, int len, const char *buf);
        -: 1050:static int fs_write_3rd_level(size_t root_blk, int offset, int len, const char *buf);
        -: 1051:
        -: 1052:
        -: 1053:
        -: 1054:/* write - write data to a file
        -: 1055: * It should return exactly the number of bytes requested, except on
        -: 1056: * error.
        -: 1057: * Errors - path resolution, ENOENT, EISDIR
        -: 1058: *  return EINVAL if 'offset' is greater than current file length.
        -: 1059: *  (POSIX semantics support the creation of files with "holes" in them,
        -: 1060: *   but we don't)
        -: 1061: */
     6685: 1062:static int fs_write(const char *path, const char *buf, size_t len,
        -: 1063:                    off_t offset, struct fuse_file_info *fi)
        -: 1064:{
        -: 1065:    int inum;
     6685: 1066:    if (!(inum = translate(path))) { // here checked path resolution
    #####: 1067:        return inum;
        -: 1068:    }
     6685: 1069:    struct fs5600_inode *inode = &inode_region[inum];
     6685: 1070:    if (offset > inode->size) {// check tmp_offset is no larger than file size
    #####: 1071:        return -EINVAL;
        -: 1072:    }
        -: 1073:
     6685: 1074:    int tmp_offset = offset;
     6685: 1075:    int tmp_len = len;
        -: 1076:
     6685: 1077:    if (tmp_offset < file_in_inode_sz) {
      323: 1078:        int written_len = fs_write_1st_level(inum, tmp_offset, tmp_len, buf);
      323: 1079:        tmp_offset += written_len;
      323: 1080:        tmp_len -= written_len;
      323: 1081:        buf += written_len;
        -: 1082:    }
    13086: 1083:    if (tmp_offset >= file_in_inode_sz &&
     6401: 1084:            tmp_offset < file_in_inode_sz + file_1st_level_sz) {
        -: 1085:
     4455: 1086:        if (inode->indir_1 == 0) {// if indir_1 not set, set it
        -: 1087:            // find a free block
       39: 1088:            int blk_num = find_free_block_number();
       39: 1089:            if (blk_num < 0) {
    #####: 1090:                return tmp_offset - offset;
        -: 1091:            }
        -: 1092:            /*change the inode*/
       39: 1093:            inode->indir_1 = blk_num;
       39: 1094:            update_inode(inum);
        -: 1095:            /*set the block bitmap*/
       39: 1096:            FD_SET(blk_num, block_map);
       39: 1097:            update_bitmap();
        -: 1098:        }
     4455: 1099:        int written_len = fs_write_2nd_level(inode->indir_1, tmp_offset, tmp_len, buf);
     4455: 1100:        tmp_offset += written_len;
     4455: 1101:        tmp_len -= written_len;
     4455: 1102:        buf += written_len;
        -: 1103:    }
     8649: 1104:    if (tmp_offset >= file_in_inode_sz + file_1st_level_sz &&
     1964: 1105:            tmp_offset <= file_in_inode_sz + file_1st_level_sz + file_2nd_level_sz) {
     1964: 1106:        if (inode->indir_2 == 0) { // if indir_2 not set, set it
        -: 1107:            // find a free block
       18: 1108:            int blk_num = find_free_block_number();
       18: 1109:            if (blk_num < 0) {
    #####: 1110:                return tmp_offset - offset;
        -: 1111:            }
        -: 1112:            /*change the inode*/
       18: 1113:            inode->indir_2 = blk_num;
       18: 1114:            update_inode(inum);
        -: 1115:            /*set the block bitmap*/
       18: 1116:            FD_SET(blk_num, block_map);
       18: 1117:            update_bitmap();
        -: 1118:        }
     1964: 1119:        int written_len = fs_write_3rd_level(inode->indir_2, tmp_offset, tmp_len, buf);
     1964: 1120:        tmp_offset += written_len;
     1964: 1121:        tmp_len -= written_len;
     1964: 1122:        buf += written_len;
        -: 1123:    }
        -: 1124:    /* update inode size */
     6685: 1125:    if (tmp_offset > inode->size) {
     6683: 1126:        inode->size = tmp_offset;
     6683: 1127:        update_inode(inum);
        -: 1128:    }
        -: 1129:    // printf("written length: %d\n", (int)(tmp_offset - offset));
     6685: 1130:    return tmp_offset - offset;
        -: 1131:}
        -: 1132:
      323: 1133:static int fs_write_1st_level(int inum, off_t offset, size_t len, const char *buf) {
      323: 1134:    int written_length = 0;
      323: 1135:    struct fs5600_inode *inode = &inode_region[inum];
      323: 1136:    int block_direct = offset / BLOCK_SIZE;
      323: 1137:    int temp_len = len;
        -: 1138:    int in_blk_len;
      323: 1139:    int in_blk_offset = offset % BLOCK_SIZE;
        -: 1140:
      808: 1141:    for (; block_direct < N_DIRECT && temp_len > 0; in_blk_offset = 0, block_direct++) {
      485: 1142:        if (temp_len + in_blk_offset > BLOCK_SIZE) {
      198: 1143:            in_blk_len = BLOCK_SIZE - in_blk_offset;
      198: 1144:            temp_len -= in_blk_len;
        -: 1145:        } else {
      287: 1146:            in_blk_len = temp_len;
      287: 1147:            temp_len = 0;
        -: 1148:        }
        -: 1149:        // if there is already allocated
      485: 1150:        if (inode->direct[block_direct] == 0) {
        -: 1151:            // find a free block
      263: 1152:            int blk_num = find_free_block_number();
      263: 1153:            if (blk_num < 0) {
    #####: 1154:                return written_length;
        -: 1155:            }
        -: 1156:
        -: 1157:            // change the inode
      263: 1158:            inode->direct[block_direct] = blk_num;
      263: 1159:            update_inode(inum);
        -: 1160:
        -: 1161:            // set the block bitmap
      263: 1162:            FD_SET(blk_num, block_map);
      263: 1163:            update_bitmap();
        -: 1164:        }
        -: 1165:        // write data to the found or given block
      485: 1166:        char *blk = (char*) malloc(BLOCK_SIZE);
      485: 1167:        disk->ops->read(disk, inode->direct[block_direct], 1, blk);
      485: 1168:        memcpy(blk + in_blk_offset, buf, in_blk_len);
      485: 1169:        disk->ops->write(disk, inode->direct[block_direct], 1, blk);
      485: 1170:        free(blk);
      485: 1171:        buf += in_blk_len;
      485: 1172:        written_length += in_blk_len;
        -: 1173:    }
        -: 1174:
      323: 1175:    return written_length;
        -: 1176:}
        -: 1177:
     6437: 1178:static int fs_write_2nd_level(size_t root_blk, int offset, int len, const char *buf){
     6437: 1179:    int written_length = 0;
     6437: 1180:    int h1t_offset = offset - file_in_inode_sz; // height 1 tree offset
     6437: 1181:    int block_direct = h1t_offset / BLOCK_SIZE;
     6437: 1182:    int temp_len = len;
        -: 1183:    int in_blk_len;
     6437: 1184:    int in_blk_offset = h1t_offset % BLOCK_SIZE;
        -: 1185:
        -: 1186:
        -: 1187:    int h1t_blk[256];
     6437: 1188:    disk->ops->read(disk, root_blk, 1, h1t_blk);
        -: 1189:
    23253: 1190:    for (; block_direct < 256 && temp_len > 0; in_blk_offset = 0, block_direct++) {
    16820: 1191:        if (temp_len + in_blk_offset > BLOCK_SIZE) {
    10404: 1192:            in_blk_len = BLOCK_SIZE - in_blk_offset;
    10404: 1193:            temp_len -= in_blk_len;
        -: 1194:        } else {
     6416: 1195:            in_blk_len = temp_len;
     6416: 1196:            temp_len = 0;
        -: 1197:        }
    16820: 1198:        if (h1t_blk[block_direct] == 0) { // if h1t_blk block direct is not used, allocate a block
        -: 1199:            /*find a free block*/
    14198: 1200:            int blk_num = find_free_block_number();
    14198: 1201:            if (blk_num < 0) {
        4: 1202:                return written_length;
        -: 1203:            }
        -: 1204:            /*change the h1t block and write back*/
    14194: 1205:            h1t_blk[block_direct] = blk_num;
    14194: 1206:            disk->ops->write(disk, root_blk, 1, h1t_blk);
        -: 1207:            /*set the block bitmap*/
    14194: 1208:            FD_SET(blk_num, block_map);
    14194: 1209:            update_bitmap();
        -: 1210:        }
    16816: 1211:        char *blk = (char*) malloc(BLOCK_SIZE);
    16816: 1212:        disk->ops->read(disk, h1t_blk[block_direct], 1, blk);
    16816: 1213:        memcpy(blk + in_blk_offset, buf, in_blk_len);
        -: 1214:
    16816: 1215:        disk->ops->write(disk, h1t_blk[block_direct], 1, blk);
    16816: 1216:        free(blk);
    16816: 1217:        buf += in_blk_len;
    16816: 1218:        written_length += in_blk_len;
        -: 1219:    }
        -: 1220:
     6433: 1221:    return written_length;
        -: 1222:}
        -: 1223:
     1964: 1224:static int fs_write_3rd_level(size_t root_blk, int offset, int len, const char *buf) {
     1964: 1225:    int written_length = 0;
     1964: 1226:    int h2t_offset = offset - file_in_inode_sz - file_1st_level_sz;// height 2 tree offset
     1964: 1227:    int block_direct = h2t_offset / file_1st_level_sz;
     1964: 1228:    int temp_len = len;
        -: 1229:    int in_blk_len;
     1964: 1230:    int in_blk_offset = h2t_offset % file_1st_level_sz;
        -: 1231:
        -: 1232:    int h2t_blk[256];
     1964: 1233:    disk->ops->read(disk, root_blk, 1, h2t_blk);
        -: 1234:
     3944: 1235:    for (; block_direct < 256 && temp_len > 0; in_blk_offset = 0, block_direct++) {
     1982: 1236:        if (temp_len + in_blk_offset > file_1st_level_sz) {
       18: 1237:            in_blk_len = file_1st_level_sz - in_blk_offset;
       18: 1238:            temp_len -= in_blk_len;
        -: 1239:        } else {
     1964: 1240:            in_blk_len = temp_len;
     1964: 1241:            temp_len = 0;
        -: 1242:        }
        -: 1243:        // if h2t_blk block direct is not used, allocate a block
     1982: 1244:        if (h2t_blk[block_direct] == 0) {
        -: 1245:            // find a free block
       36: 1246:            int blk_num = find_free_block_number();
       36: 1247:            if (blk_num < 0) {
    #####: 1248:                return written_length;
        -: 1249:            }
        -: 1250:
        -: 1251:            // change the h2t block and write back
       36: 1252:            h2t_blk[block_direct] = blk_num;
       36: 1253:            disk->ops->write(disk, root_blk, 1, h2t_blk);
        -: 1254:
        -: 1255:            // set the block bitmap
       36: 1256:            FD_SET(blk_num, block_map);
       36: 1257:            update_bitmap();
        -: 1258:        }
     1982: 1259:        int written_length_next_level = fs_write_2nd_level(h2t_blk[block_direct], in_blk_offset + N_DIRECT * BLOCK_SIZE, in_blk_len, buf);
     1982: 1260:        if(written_length_next_level == 0) {
        2: 1261:            break;
        -: 1262:        }
     1980: 1263:        buf += written_length_next_level;
     1980: 1264:        written_length += written_length_next_level;
        -: 1265:    }
        -: 1266:
     1964: 1267:    return written_length;
        -: 1268:}
        -: 1269:
    15195: 1270:void update_bitmap() {
    15195: 1271:    disk->ops->write(disk, 1, inode_map_sz, inode_map);
    15195: 1272:    disk->ops->write(disk, 1 + inode_map_sz, block_map_sz, block_map);
    15195: 1273:}
        -: 1274:
        -: 1275:
    14586: 1276:int find_free_block_number() {
        -: 1277:    int i;
  9336715: 1278:    for (i = 0; i < block_map_sz * BLOCK_SIZE * 8 && i < num_of_blocks; i++) {
  9336711: 1279:        if (!FD_ISSET(i, block_map)) {
    14582: 1280:            int *clear_blk = calloc(1, BLOCK_SIZE);
    14582: 1281:            disk->ops->write(disk, i, 1, clear_blk);
    14582: 1282:            free(clear_blk);
    14582: 1283:            return i;
        -: 1284:        }
        -: 1285:    }
        -: 1286:
        4: 1287:    return -ENOSPC;
        -: 1288:}
        -: 1289:
        -: 1290:/* statfs - get file system statistics
        -: 1291: * see 'man 2 statfs' for description of 'struct statvfs'.
        -: 1292: * Errors - none.
        -: 1293: */
    #####: 1294:static int fs_statfs(const char *path, struct statvfs *st)
        -: 1295:{
        -: 1296:    /* Already implemented. Optional - set the following:
        -: 1297:     *  f_blocks - total blocks in file system
        -: 1298:     *  f_bfree, f_bavail - unused blocks
        -: 1299:     * You could calculate bfree dynamically by scanning the block
        -: 1300:     * allocation map.
        -: 1301:     */
    #####: 1302:    st->f_bsize = FS_BLOCK_SIZE;
    #####: 1303:    st->f_blocks = 0;
    #####: 1304:    st->f_bfree = 0;
    #####: 1305:    st->f_bavail = 0;
    #####: 1306:    st->f_namemax = 27;
        -: 1307:
    #####: 1308:    return 0;
        -: 1309:}
        -: 1310:
        -: 1311:/* operations vector. Please don't rename it, as the skeleton code in
        -: 1312: * misc.c assumes it is named 'fs_ops'.
        -: 1313: */
        -: 1314:struct fuse_operations fs_ops = {
        -: 1315:    .init = fs_init,
        -: 1316:    .getattr = fs_getattr,
        -: 1317:    .readdir = fs_readdir,
        -: 1318:    .mknod = fs_mknod,
        -: 1319:    .mkdir = fs_mkdir,
        -: 1320:    .unlink = fs_unlink,
        -: 1321:    .rmdir = fs_rmdir,
        -: 1322:    .rename = fs_rename,
        -: 1323:    .chmod = fs_chmod,
        -: 1324:    .utime = fs_utime,
        -: 1325:    .truncate = fs_truncate,
        -: 1326:    .read = fs_read,
        -: 1327:    .write = fs_write,
        -: 1328:    .statfs = fs_statfs,
        -: 1329:};
        -: 1330:
